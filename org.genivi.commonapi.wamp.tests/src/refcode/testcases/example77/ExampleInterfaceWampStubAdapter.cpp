/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.wamp (standalone).
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/

#include <CommonAPI/Wamp/WampConnection.hpp>
#include <CommonAPI/Wamp/WampClientId.hpp>

#include "testcase/example77/ExampleInterface.hpp"
#include "testcase/example77/ExampleInterfaceWampStubAdapter.hpp"
#include "testcase/example77/ExampleInterfaceWampStructsSupport.hpp"

#include <functional>

namespace testcases {
namespace example77 {

std::shared_ptr<CommonAPI::Wamp::WampStubAdapter> createExampleInterfaceWampStubAdapter(
                   const CommonAPI::Wamp::WampAddress &_address,
                   const std::shared_ptr<CommonAPI::Wamp::WampProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    std::cout << "createExampleInterfaceWampStubAdapter called" << std::endl;
    return std::make_shared<ExampleInterfaceWampStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerExampleInterfaceWampStubAdapter) {
    CommonAPI::Wamp::Factory::get()->registerStubAdapterCreateMethod(
    	ExampleInterface::getInterface(), &createExampleInterfaceWampStubAdapter);
    std::cout << "registerStubAdapterCreateMethod(createExampleInterfaceWampStubAdapter)" << std::endl;
}

ExampleInterfaceWampStubAdapterInternal::~ExampleInterfaceWampStubAdapterInternal() {
    deactivateManagedInstances();
    ExampleInterfaceWampStubAdapterHelper::deinit();
}

void ExampleInterfaceWampStubAdapterInternal::deactivateManagedInstances() {

}

/* TODO: Is this needed?
const char* ExampleInterfaceDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"play\">\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}
*/

CommonAPI::Wamp::WampGetAttributeStubDispatcher<
        ::example::ExampleInterfaceStub,
        CommonAPI::Version
        > ExampleInterfaceWampStubAdapterInternal::getExampleInterfaceInterfaceVersionStubDispatcher(&ExampleInterfaceStub::getInterfaceVersion, "uu");




CommonAPI::Wamp::WampMethodWithReplyStubDispatcher<
    ::example::ExampleInterfaceStub,
    std::tuple<>,
    std::tuple<>,
    std::tuple<>,
    std::tuple<>
    
    > ExampleInterfaceWampStubAdapterInternal::playStubDispatcher(
    &ExampleInterfaceStub::play, "",
					std::make_tuple(),
                	std::make_tuple());





const ExampleInterfaceWampStubAdapterHelper::StubDispatcherTable& ExampleInterfaceWampStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::Wamp::StubAttributeTable& ExampleInterfaceWampStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

ExampleInterfaceWampStubAdapterInternal::ExampleInterfaceWampStubAdapterInternal(
        const CommonAPI::Wamp::WampAddress &_address,
        const std::shared_ptr<CommonAPI::Wamp::WampProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::Wamp::WampStubAdapter(_address, _connection, false),
      ExampleInterfaceWampStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<ExampleInterfaceStub>(_stub), false),
      stubDispatcherTable_({
            { { "play", "" }, &example::ExampleInterfaceWampStubAdapterInternal::playStubDispatcher }
            }),
        stubAttributeTable_() {
	std::cout << "ExampleInterfaceWampStubAdapterInternal constructor called" << std::endl;
    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &example::ExampleInterfaceWampStubAdapterInternal::getExampleInterfaceInterfaceVersionStubDispatcher });
}


//////////////////////////////////////////////////////////////////////////////////////////

void ExampleInterfaceWampStubAdapterInternal::provideRemoteMethods() {
    std::cout << "provideRemoteMethods called" << std::endl;

	// busy waiting until the session is started and joined
    while(!getWampConnection()->isConnected());

    CommonAPI::Wamp::WampConnection* connection = (CommonAPI::Wamp::WampConnection*)(getWampConnection().get());
    connection->ioMutex_.lock();

    boost::future<void> provide_future_play = connection->session_->provide(getWampAddress().getRealm() + ".play",
    		std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_play, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
        try {
            std::cerr << "registered procedure " << getWampAddress().getRealm() << ".play: id=" << registration.get().id() << std::endl;
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            connection->io_.stop();
            return;
        }
    });
    provide_future_play.get();

//    boost::future<void> provide_future_add2 = connection->session_->provide("add2",
    boost::future<void> provide_future_add2 = connection->session_->provide(getWampAddress().getRealm() + ".add2",
    		std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
        try {
            std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2: id=" << registration.get().id() << std::endl;
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            connection->io_.stop();
            return;
        }
    });
    provide_future_add2.get();

    boost::future<void> provide_future_add2struct = connection->session_->provide(getWampAddress().getRealm() + ".add2struct",
    		std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2struct, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
        try {
            std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2struct: id=" << registration.get().id() << std::endl;
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            connection->io_.stop();
            return;
        }
    });
    provide_future_add2struct.get();

    boost::future<void> provide_future_add2nestedStruct = connection->session_->provide(getWampAddress().getRealm() + ".add2nestedStruct",
    		std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
        try {
            std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2nestedStruct: id=" << registration.get().id() << std::endl;
        } catch (const std::exception& e) {
            std::cerr << e.what() << std::endl;
            connection->io_.stop();
            return;
        }
    });
    provide_future_add2nestedStruct.get();

    connection->ioMutex_.unlock();
}


void ExampleInterfaceWampStubAdapterInternal::wrap_play(autobahn::wamp_invocation invocation) {
	std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_play called" << std::endl;
    auto clientNumber = invocation->argument<uint32_t>(0);
    std::cerr << "Procedure " << getWampAddress().getRealm() << ".play invoked (clientNumber=" << clientNumber << ")" << std::endl;
    std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
    stub_->play(clientId, [&]() {});
}

/*
struct LocalSummands
{
    uint64_t left;
    uint64_t right;

    MSGPACK_DEFINE(left, right)
};

struct LocalSumDiff
{
    uint64_t sum;
    uint64_t diff;

    MSGPACK_DEFINE(sum, diff)
};
*/

void ExampleInterfaceWampStubAdapterInternal::wrap_add2(autobahn::wamp_invocation invocation) {
    std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2 called" << std::endl;

    auto clientNumber = invocation->argument<uint32_t>(0);
    auto left = invocation->argument<int64_t>(1);
    auto right = invocation->argument<int64_t>(2);

    std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2 invoked (clientNumber=" << clientNumber << "): left=" << left << ", right=" << right << std::endl;

    std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
    int64_t sum;
    int64_t diff;
    stub_->add2(clientId, left, right, [&](int64_t _sum, int64_t _diff) {sum=_sum; diff=_diff;});

    invocation->result(std::make_tuple(sum, diff));
}

void ExampleInterfaceWampStubAdapterInternal::wrap_add2struct(autobahn::wamp_invocation invocation) {
    std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2struct called" << std::endl;

    auto clientNumber = invocation->argument<uint32_t>(0);
    Summands s;
    s.values_ = invocation->argument<std::tuple<uint64_t, uint64_t>>(1);

    std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2struct invoked (clientNumber=" << clientNumber << "): s=(left=" << s.getLeft() << ", right=" << s.getRight() << ")" << std::endl;

    std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
    SumDiff result;
    stub_->add2struct(clientId, s, [&](SumDiff _result) {result=_result;});

    invocation->result(std::make_tuple(result.values_));
}

void ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct(autobahn::wamp_invocation invocation) {
    std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct called" << std::endl;

    auto clientNumber = invocation->argument<uint32_t>(0);
    Params_internal p_internal = invocation->argument<Params_internal>(1);
    Params p = transformParams(p_internal);

    std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2nestedStruct invoked (clientNumber=" << clientNumber << "): p=((left=" << p.getSs().getLeft() << ", right=" << p.getSs().getRight() << "), x=" << p.getX() << ")" << std::endl;

    std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
    SumDiff result;
    stub_->add2nestedStruct(clientId, p, [&](SumDiff _result) {result=_result;});

    invocation->result(std::make_tuple(result.values_));
}

//////////////////////////////////////////////////////////////////////////////////////////


} // namespace example77
} // namespace testcases
