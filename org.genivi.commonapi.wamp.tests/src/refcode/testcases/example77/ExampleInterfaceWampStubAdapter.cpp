/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.wamp (standalone).
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/

#include <CommonAPI/Wamp/WampConnection.hpp>
#include <CommonAPI/Wamp/WampClientId.hpp>

#include "testcases/example77/ExampleInterface.hpp"
#include "testcases/example77/ExampleInterfaceWampStubAdapter.hpp"
#include "testcases/example77/ExampleInterfaceWampStructsSupport.hpp"

#include <functional>

namespace testcases {
namespace example77 {

std::shared_ptr<CommonAPI::Wamp::WampStubAdapter> createExampleInterfaceWampStubAdapter(
						const CommonAPI::Wamp::WampAddress &_address,
						const std::shared_ptr<CommonAPI::Wamp::WampProxyConnection> &_connection,
						const std::shared_ptr<CommonAPI::StubBase> &_stub) {
	std::cout << "createExampleInterfaceWampStubAdapter called" << std::endl;
	return std::make_shared<ExampleInterfaceWampStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerExampleInterfaceWampStubAdapter) {
	CommonAPI::Wamp::Factory::get()->registerStubAdapterCreateMethod(
		ExampleInterface::getInterface(), &createExampleInterfaceWampStubAdapter);
	std::cout << "registerStubAdapterCreateMethod(createExampleInterfaceWampStubAdapter)" << std::endl;
}

ExampleInterfaceWampStubAdapterInternal::~ExampleInterfaceWampStubAdapterInternal() {
	deactivateManagedInstances();
	ExampleInterfaceWampStubAdapterHelper::deinit();
}

void ExampleInterfaceWampStubAdapterInternal::deactivateManagedInstances() {

}

CommonAPI::Wamp::WampGetAttributeStubDispatcher<
	::testcases::example77::ExampleInterfaceStub,
	CommonAPI::Version
> ExampleInterfaceWampStubAdapterInternal::getExampleInterfaceInterfaceVersionStubDispatcher(&ExampleInterfaceStub::getInterfaceVersion, "uu");


CommonAPI::Wamp::WampMethodWithReplyStubDispatcher<
	::testcases::example77::ExampleInterfaceStub,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>
> ExampleInterfaceWampStubAdapterInternal::playStubDispatcher(
	&ExampleInterfaceStub::play, "",
					std::make_tuple(),
					std::make_tuple());

CommonAPI::Wamp::WampMethodWithReplyStubDispatcher<
	::testcases::example77::ExampleInterfaceStub,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>
> ExampleInterfaceWampStubAdapterInternal::add2StubDispatcher(
	&ExampleInterfaceStub::add2, "",
					std::make_tuple(),
					std::make_tuple());

CommonAPI::Wamp::WampMethodWithReplyStubDispatcher<
	::testcases::example77::ExampleInterfaceStub,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>
> ExampleInterfaceWampStubAdapterInternal::add2structStubDispatcher(
	&ExampleInterfaceStub::add2struct, "",
					std::make_tuple(),
					std::make_tuple());

CommonAPI::Wamp::WampMethodWithReplyStubDispatcher<
	::testcases::example77::ExampleInterfaceStub,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>,
	std::tuple<>
> ExampleInterfaceWampStubAdapterInternal::add2nestedStructStubDispatcher(
	&ExampleInterfaceStub::add2nestedStruct, "",
					std::make_tuple(),
					std::make_tuple());



const ExampleInterfaceWampStubAdapterHelper::StubDispatcherTable& ExampleInterfaceWampStubAdapterInternal::getStubDispatcherTable() {
	return stubDispatcherTable_;
}

const CommonAPI::Wamp::StubAttributeTable& ExampleInterfaceWampStubAdapterInternal::getStubAttributeTable() {
	return stubAttributeTable_;
}

ExampleInterfaceWampStubAdapterInternal::ExampleInterfaceWampStubAdapterInternal(
		const CommonAPI::Wamp::WampAddress &_address,
		const std::shared_ptr<CommonAPI::Wamp::WampProxyConnection> &_connection,
		const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::Wamp::WampStubAdapter(_address, _connection, false),
	  ExampleInterfaceWampStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<ExampleInterfaceStub>(_stub), false),
	  stubDispatcherTable_({
			{ { "play", "" }, &example::ExampleInterfaceWampStubAdapterInternal::playStubDispatcher }
			{ { "add2", "" }, &example::ExampleInterfaceWampStubAdapterInternal::add2StubDispatcher }
			{ { "add2struct", "" }, &example::ExampleInterfaceWampStubAdapterInternal::add2structStubDispatcher }
			{ { "add2nestedStruct", "" }, &example::ExampleInterfaceWampStubAdapterInternal::add2nestedStructStubDispatcher }
			}),
		stubAttributeTable_() {
	std::cout << "ExampleInterfaceWampStubAdapterInternal constructor called" << std::endl;
	stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &/*namespace::*/ExampleInterfaceWampStubAdapterInternal::getExampleInterfaceInterfaceVersionStubDispatcher });
}


//////////////////////////////////////////////////////////////////////////////////////////

void ExampleInterfaceWampStubAdapterInternal::provideRemoteMethods() {
	std::cout << "provideRemoteMethods called" << std::endl;

	// busy waiting until the session is started and joined
	while(!getWampConnection()->isConnected());

	CommonAPI::Wamp::WampConnection* connection = (CommonAPI::Wamp::WampConnection*)(getWampConnection().get());
	connection->ioMutex_.lock();

	boost::future<void> provide_future_play = connection->session_->provide(getWampAddress().getRealm() + ".play",
			std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_play, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
		try {
			std::cerr << "registered procedure " << getWampAddress().getRealm() << ".play: id=" << registration.get().id() << std::endl;
		} catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			connection->io_.stop();
			return;
		}
	});
	provide_future_play.get();

	boost::future<void> provide_future_add2 = connection->session_->provide(getWampAddress().getRealm() + ".add2",
			std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
		try {
			std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2: id=" << registration.get().id() << std::endl;
		} catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			connection->io_.stop();
			return;
		}
	});
	provide_future_add2.get();

	boost::future<void> provide_future_add2struct = connection->session_->provide(getWampAddress().getRealm() + ".add2struct",
			std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2struct, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
		try {
			std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2struct: id=" << registration.get().id() << std::endl;
		} catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			connection->io_.stop();
			return;
		}
	});
	provide_future_add2struct.get();

	boost::future<void> provide_future_add2nestedStruct = connection->session_->provide(getWampAddress().getRealm() + ".add2nestedStruct",
			std::bind(&ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct, this, std::placeholders::_1))
		.then([&](boost::future<autobahn::wamp_registration> registration) {
		try {
			std::cerr << "registered procedure " << getWampAddress().getRealm() << ".add2nestedStruct: id=" << registration.get().id() << std::endl;
		} catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			connection->io_.stop();
			return;
		}
	});
	provide_future_add2nestedStruct.get();

	connection->ioMutex_.unlock();
}


void ExampleInterfaceWampStubAdapterInternal::wrap_play(autobahn::wamp_invocation invocation) {
	std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_play called" << std::endl;
	auto clientNumber = invocation->argument<uint32_t>(0);
	std::cerr << "Procedure " << getWampAddress().getRealm() << ".play invoked (clientNumber=" << clientNumber << ") " << std::endl;
	std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
	stub_->play(clientId, [&]() {});
}
void ExampleInterfaceWampStubAdapterInternal::wrap_add2(autobahn::wamp_invocation invocation) {
	std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2 called" << std::endl;
	auto clientNumber = invocation->argument<uint32_t>(0);
	auto left = invocation->argument<int64_t>(1);
	auto right = invocation->argument<int64_t>(2);
	std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2 invoked (clientNumber=" << clientNumber << ") " << "left=" << left << ", right=" << right << std::endl;
	std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
	int64_t sum;
	int64_t diff;
	stub_->add2(clientId, left, right, [&](int64_t _sum, int64_t _diff) {sum=_sum; diff=_diff; });
	invocation->result(std::make_tuple(sum, diff));
}
void ExampleInterfaceWampStubAdapterInternal::wrap_add2struct(autobahn::wamp_invocation invocation) {
	std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2struct called" << std::endl;
	auto clientNumber = invocation->argument<uint32_t>(0);
	Summands_internal s_internal = invocation->argument<Summands_internal>(1);
	Summands s = transformSummands(s_internal);
	std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2struct invoked (clientNumber=" << clientNumber << ") " << std::endl;
	std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
	SumDiff result;
	stub_->add2struct(clientId, s, [&](SumDiff _result) {result=_result; });
	invocation->result(std::make_tuple(result.values_));
}
void ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct(autobahn::wamp_invocation invocation) {
	std::cout << "ExampleInterfaceWampStubAdapterInternal::wrap_add2nestedStruct called" << std::endl;
	auto clientNumber = invocation->argument<uint32_t>(0);
	Params_internal p_internal = invocation->argument<Params_internal>(1);
	Params p = transformParams(p_internal);
	std::cerr << "Procedure " << getWampAddress().getRealm() << ".add2nestedStruct invoked (clientNumber=" << clientNumber << ") " << std::endl;
	std::shared_ptr<CommonAPI::Wamp::WampClientId> clientId = std::make_shared<CommonAPI::Wamp::WampClientId>(clientNumber);
	SumDiff result;
	stub_->add2nestedStruct(clientId, p, [&](SumDiff _result) {result=_result; });
	invocation->result(std::make_tuple(result.values_));
}

} // namespace example77
} // namespace testcases
